Project 3 Report

1: Class Descriptions

StudentWorld:
	StudentWorld(std::string assetDir)
		-Constructs the student world
		- sets private variables storing the number of ticks and the current level to 0
	~StudentWorld();
		- Destructs student world
		- frees dynamically allocated memory
	virtual int init();
		- initializes the each level
		- dynamically allocates memory for player and other game objects (stored in vector) and places them on field
		- returns integer indicating the game should continue
		- function is virtual as per the spec, in case a derived class needs to be created later
	virtual int move();
		- sets the game text
		- creates new game objects if necessary
		- increments tick counter
		- tells all currently alive objects to do something
		- calls generateExitMap() & generatePlayerMap() to create 2D integer arrays containing the distance to the exit and player
		  respectively
		- returns an integer indicating if the level is finished, the player has died, or the game shoudl continue
		- function is virtual as per the spec, in case a derived class needs to be created later
	virtual void cleanUp();
		- frees all dynamically allocated memory for level
	int randInt(int low, int high);
		- generates a random integer from low to high-1 inclusive;
	int getLevel();
		- returns current level number
	int getTicks();
		- returns current tick number
	void removeDirt(int x, int y, bool sound);
		- destroys Dirt object at (x,y)
		- plays digging sound if the boolean parameter is true
	FrackMan* getPlayer();
		- returns a pointer to the player object
	bool isDirt(int x, int y);
		- returns true if (x,y) contains Dirt
	bool containsDirt(int x1, int y1, int x2, int y2);
		- returns true if the rectangle starting at (x1,y1) with width x2 and height y2 contains any Dirt
	bool containsBoulderAtDistance(int x1, int y1, int x2, int y2, double distance);
		- returns true if there is a Boulder <= distance units from any point in
		  the rectangle starting at (x1,y1) with width x2 and height y2
	bool overlapsBoulder(int x, int y, int size);
		- checks if an object of with a size equal to the parameter would overlap a Boulder if it was located at (x,y)
	void nearProtester(int x, int y, int dmg, Actor* caller);
		- called by an actor
		- annoys or kills protester within 3.0 of (x,y)
		- increases score if necessary
	bool nearNugget(int x, int y);
		- returns true if there is Gold within 3.0 of (x,y)
		- kills the gold if it can be picked up by a protester, increases score by 25 if it is a hardcore protester
	bool nearBoulder(int x, int y);
		- returns true if there is a boulder withn 3.0 of (x,y)
	void decOil();
		- decrements count of oil left on field
	void playerDropGold();
		- creates a new Gold object on the field that can be picked up by a protester
		- decrements player's gold count
	void playerSquirt(int x, int y);
		- creates a Squirt object at (x,y)
	void activateSonar(int x, int y);
		- sets all objects within 12.0 of player to visible
	void createSonarOrWater();
		- calculates if new Water or Sonar object should be added to the field
		- if Water is created
			-finds all open 4x4 spaces and randomly places the water
		- if Sonar is created, places it (0,60)
	int numObjects();
		- returns the number of non-Dirt and non-Player objects
	void floodFill(int x, int y, int  map[66][66]);
		- generates a map of the field marking each point with the number of moves needed to reach (x,y)
		  using a breadth first flood fill algorithm (Lee's algorithm)

		Pseudocode:
			push starting coordinate onto queue
			set start to 0
			while queue not empty
				current = top of queue
				pop queue
				mark all reachable adjacent coordinates with current's value + 1
				push all rachable adjacent coordinates onto queue

			
	void generateExitMap();
		- generates a map of distances to the protesters' exit point using floodFill(int x, int y, int  map[66][66]
	void generatePlayerMap();
		- generates a map of distances to the player using floodFill(int x, int y, int  map[66][66]
	void getClosest(int x, int y, int &dir, int map[66][66]);
		- uses the map generated by either generateExitMap() or generatePlayerMap() to find the relative direction of the
		  closest square adjacent to (x,y) to a target destination
	void getClosestToPlayer(int x, int y, int &dir);
		- sets dir the the direction of the square adjacent to (x,y) closest to the player
	void getClosestToExit(int x, int y, int &dir);
		- sets dir the the direction of the square adjacent to (x,y) closest to the protesters' exit point
	int distanceToPlayer(int x, int y);
		- returns the distance to the player from (x,y)
	void printFloodFillExit(); 
		- Used for Debugging Only
		- prints the integer array generated by generateExitMap();

class Actor:
	Actor(StudentWorld* world, int imageID, int startX, int startY, Direction dir = right, double size = 1.0, unsigned int depth = 0);
		- creates an Actor with the parameters passed into it
		- sets the actor visible
	virtual ~Actor();
		- destroys the Actor object
		- is virtual so derived classes can be destructed properly
	virtual void doSomething();
		- does nothing
		- is virtual so derived classes can define their own doSomething methods
	StudentWorld* getWorld();
		- returns a pointer to the current StudentWorld the Actor is located in
	void killThis();
		- sets private boolean _alive to false
	bool isAlive();
		- returns true if the Actor is alive
	virtual bool canBeMovedTo(int x, int y);
		- determines if the Actor can move to the point (x,y)
		- is virtual so FrackMan can create it's own definition, since the FrackMan can move through Dirt
	virtual childType getType() = 0;
		- pure virtual since all derived classes must have their own getType method
	virtual void annoy(int k, int &count);
		- does nothing
		- is virtual so that some, but not all derived classes can create their own method
	virtual void numToAnnoy(int k);
		- does nothing
		- is virtual so that some, but not all derived classes can create their own method
	virtual bool getLeaving();
		- returns false
		- is virtual so Protster and HardcoreProtester objects can redefine this
	virtual void setLeaving(bool i);
		_ sets the private boolean _leaving to i
	virtual int getHP() const;
		- returns 0
		- is virtual so that derived FrackMan, Protester and HardcoreProtester define their own method
	double distanceTo(Actor* other);
		- returns the straight line distance from the Actor to other

class TerrainObject : public Actor:

	TerrainObject(StudentWorld* world, int imageID, int startX, int startY, Direction dir, double size, unsigned int depth);
		- Creates a TerrainObject with given parameters
	virtual ~TerrainObject();
		- destructs TerrainObject
		- is virtual so derived classes can be destructed properly

class Dirt : public TerrainObject:
	Dirt(StudentWorld* world, int startX, int startY);
		- Creates a Dirt object at (startX,startY)
	virtual ~Dirt();
		- destructs Dirt object
		- is virtual so derived classes can be destructed properly
	virtual childType getType();
		- returns an enumerated variable indicating this is a Dirt object
		- virtual so that any future derived classes can create their own methods

class Boulder : public TerrainObject
	Boulder(StudentWorld* world, int startX, int startY);
		- creates a Boulder Object at (startX,startY)
	virtual ~Boulder();
		- destructs Boulder object
		- is virtual so derived classes can be destructed properly
	BoulderState getState() const;
		- returns an enumerated variable indicating the state of the boulder
	void setState(BoulderState state);
		- sets a private variable indicating the boulder is stable, waiting or falling
	bool canFall();
		- returns true if the Boulder can fall (space below empty)
	virtual void doSomething();
		- sets the state to waiting if the Boulder is stable and can fall
		- if the Boulder is waiting, count each tick, play sound and set state to falling when the 30 ticks have passed
		- if the Boulder is falling and can fall further
			- move one space down
		- if any FrackMan or Protesters within 3.0, decrease their health by 100
		- kills the Boulder if the boulder hits space occupied by Dirt or another Boulder
	virtual childType getType();
		- returns an enumerated variable indicating this is a Boulder object
		- virtual so that any future derived classes can create their own methods

class Interactable : public Actor
	Interactable(StudentWorld* world, int imageID, int startX, int startY, Direction dir, double size, unsigned int depth);
		- creates an Interactable object with the given parameters
	virtual ~Interactable();
		- destructs Interactable object
		- is virtual so derived classes can be destructed properly
	void setInteractable(InteractableBy agentType);
		- sets if the object can interact with a FrackMan or Protester object
	InteractableBy getInteractable() const;
		- returns an enumerated variable indicating if the object can interact with a Protesteer or FrackMan
	virtual void numToAnnoy(int k);
		- does nothing
		- virtual so that child classes can have their own methods
	void setFound(bool found);
		- sets a private boolean to indicate if the object has been found or not
	bool getFound();
		- sets a private boolean to true, to indicate that the object has been found
	void setLifeTime(int time);
		- sets how many ticks the object will remain on the field
	void decLifeTime();
		- decrement the number of ticks the object will remain on the field
	int getLifeTime();
		- return the number of ticks the object will remain on the field

class Gold : public Interactable
	Gold(StudentWorld* world, int startX, int startY);
		- creates a Gold object that is not visible at (startX,startY)
		- makes the created Gold object able to interact with the FrackMan
	Gold(StudentWorld* world, int startX, int startY, bool visible, InteractableBy agentType);
		- creates a Gold object with the given parameters
	virtual ~Gold();
		- destructs Gold object
		- is virtual so derived classes can be destructed properly
	virtual void doSomething();
		- decrements lifetime if can interact with a protester, kills it if reaches 0
		- otherwise make visible if within 4.0 of the player
		- play a sound, increase score and kill this if within 3.0 of player
	virtual childType getType();
		- returns an enumerated variable indicating this is a Gold object
		- virtual so that any future derived classes can create their own methods

class Sonar : public Interactable
	Sonar(StudentWorld* world, int startX, int startY);
		- creates a Sonar object that is visible at (startX,startY)
		- sets lifetime of the object
		- makes the created Sonar object able to interact with the FrackMan
	virtual ~Sonar();
	virtual void doSomething();
		- decrements lifetime of SonarObject, kills it if reaches 0
		- make visible if within 4.0 of the player
		- play a sound, increase score, increase sonar charge count and kill this if within 3.0 of player
	virtual childType getType();
		- returns an enumerated variable indicating this is a Sonar object
		- virtual so that any future derived classes can create their own methods

class Oil : public Interactable
	Oil(StudentWorld* world, int startX, int startY);
		- creates a Oil object that is not visible at (startX,startY)
		- makes the created Sonar object able to interact with the FrackMan
	virtual ~Oil();
		- destructs Oil object
		- is virtual so derived classes can be destructed properly
	virtual void doSomething();
		- make visible if within 4.0 of the player
		- play a sound, increase score and kill this if within 3.0 of player
	virtual childType getType();
		- returns an enumerated variable indicating this is an Oil object
		- virtual so that any future derived classes can create their own methods

class Water : public Interactable
	Water(StudentWorld* world, int startX, int startY);
		- creates a Water object that is visible at (startX,startY)
		- sets lifetime of the object
		- makes the created Water object able to interact with the FrackMan
	virtual ~Water();
		- destructs Water object
		- is virtual so derived classes can be destructed properly
	virtual void doSomething();
		- kills object if lifetime <= 0
		- make visible if within 4.0 of the player
		- play a sound, increase score, increase squirt count and kill this if within 3.0 of player
	virtual childType getType();
		- returns an enumerated variable indicating this is an Water object
		- virtual so that any future derived classes can create their own methods

class Squirt : public Interactable
	Squirt(StudentWorld* world, int startX, int startY, Direction dir);
		- creates a Squirt object at (startX, startY) facing dir
		- sets number of steps traveled to 0
	virtual ~Squirt();
		- destructs Squirt object
		- is virtual so derived classes can be destructed properly
	virtual void doSomething();
		- kills this and returns if distance travelled >= 4
		- checks if near protestors, makes the StudentWorld handle the interaction
		- advances 1 unit in current direction
	virtual childType getType();
		- returns an enumerated variable indicating this is an Squirt object
		- virtual so that any future derived classes can create their own methods
	virtual bool canBeMovedTo(int x, int y);
		- returns true if a Squirt can be placed at (x,y)
	void incDist();
		- increment counter variable for distance traveled
	virtual void numToAnnoy(int k);
		- sets the number of protesters to annoy to k

class Agent : public Actor
	Agent(StudentWorld* world, int imageID, int startX, int startY, Direction dir, double size, unsigned int depth);
		- creates an Agent object with the given parameters
	virtual ~Agent();
		- destructs Agent object
		- is virtual so derived classes can be destructed properly
	virtual int getHP() const;
		- returns the object's current health
	void setHP(int hp);
		- sets private member storing health to hp
	virtual void decHPBy(int k);
		- decrements health by k

class Protester: public Agent
	Protester(StudentWorld* world, int startX, int startY, bool isHardcore = false);
		- creates a Protester at (startX,startY)
		  (fourth parameter is only used by HardcoreProtesters's initializer list)
		- sets health to 5
	virtual ~Protester();
		- destructs Protester object
		- is virtual so derived classes can be destructed properly
	virtual childType getType();
		- returns an enumerated variable indicating this is an Protester object
		- virtual so that any future derived classes can create their own methods
	virtual void doSomething();
		- determines if the Protester should move or not
		- causes Protester to shout if close enough to player
		- causes Protester to turn and step towards the player if line of sight to the player is clear
		- calls hardCoreMovement()
			- steps towards player if it returns true
			- otherwise does nothing
 		- makes Protester follow other movement patterns indicated in spec
	virtual bool hardCoreMovement();
		- returns false
		- is virtual so HardcoreProtesters can have a different method
	virtual bool canBeMovedTo(int x, int y);
		- returns true if the object can be at to (x,y) without being in Dirt of with 3.0 of a Boulder
		- is virtual so derived classes can have different method
	virtual void getBribed();
		- increases score, instructs Protester object to leave the field
	ProtestState getState();
		- returns if protester is active or resting
	bool lineOfSightToPlayer();
		- returns true if there is straight line path to the player
	void stepRight();
		- if the Protester can step right, sets direction to right and moves forward
	void stepLeft();
		- if the Protester can step left, sets direction to left and moves forward
	void stepDown();
		-if the Protester can step down, sets direction to down and moves forward
	void stepUp();
		-if the Protester can step up, sets direction to up and moves forward
	void stepCurrentDir();
		- if the Protester can step in it's current direction, move forward
	bool canMoveUp();
		- returns true if the protestor can move up
	bool canMoveDown();
		- returns true if the protestor can move down
	bool canMoveLeft();
		- returns true if the protestor can move left
	bool canMoveRight();
		- returns true if the protestor can move right
	void setLeaving(bool i);
		- sets boolean indicating Protester should leave to i
	bool getLeaving();
		 - returns true if the Protester is leaving the field
	void moveTowardsExit();
		- Protester moves one square closer to the exit
	void moveTowardsPlayer();
		- Protester moves one square closer to the player
	void setStun();
		- sets boolean indicating Protester is stunned

class HardcoreProtester : public Protester
	HardcoreProtester(StudentWorld* world, int startX, int startY);
		- creates a HardcoreProtester at (startX,startY)
		- sets health to 20
	virtual ~HardcoreProtester();
		- returns an enumerated variable indicating this is an Protester object
		- virtual so that any future derived classes can create their own methods
	virtual bool hardCoreMovement();
		- calculates if player is close enough to object to chase
		- moves towards player and returns true if it is
		- virtual so that any future derived classes can create their own methods
	virtual void getBribed();
		- increases score
		- stuns HardcoreProtester
		- virtual so that any future derived classes can create their own methods
	virtual childType getType();
		- returns an enumerated variable indicating this is an HardcoreProtester object
		- virtual so that any future derived classes can create their own methods

class FrackMan : public Agent
	FrackMan(StudentWorld* world, int hp = FRACKMAN_HP ,int water = 5,int sonar = 1, int gold = 0);
		- contructs FrackMan object, default values used for testing
	virtual ~FrackMan();
		- destructs FrackMan object
	virtual void doSomething();
		- handles player input (moving, squirting, dropping gold, etc.)
	virtual bool canBeMovedTo(int x, int y);
		- returns false if (x,y) is out of bounds or within 3.0 of a boulder
	virtual childType getType();
	void incGold();
		- decrements gold cound
	void decGold();
		- increments gold cound
	int getGold();
		- returns gold cound
	void decSquirt();
		- decrements squirt count
	void incSquirtBy(int k);
		- increments squirt count by k
	int getSquirtCount();
		- returns squirt count
	void incSonarBy(int k);
		- increases sonar kit count by k
	void decSonar();
		- decrements sonar count
	int getSonar();
		- returns sonar count

2: Functionality not Implemented and Known Bugs
	
	To my knowledge I have implemented all functionality detailed in the spec.
	
	During testing a Hardcore Protester became stuck inside a boulder once, I was unable to find the cause of this bug
	and it has not been reproduced since.	

	During later levels, game objects have been placed in the mineshaft despite those coordinates being removed from the list
	of possible starting positions

3: Design Decisions

	It was ambiguous if intersection meant any point where a Protester could turn, or if the point had to be bounded by Dirt/Boulders
	so I assumed it meant any point where turning was possible.

	I had the StudentWorld handle interactions between most objects rather than the objects themselves.

4: Class Testing

StudentWorld:
To test StudentWorld, I first made sure the default init, move and cleanup methods worked properly. Then I had the init method create
the FrackMan and Dirt field and ensured that they both appeared when the game started. After that I implemented a method to randomly
place objects and tested it by filling the grid with 20 boulders and making sure non of them started in illegal starting positions.
Then I created a method to monitor the current tick, and printed it to the top of the screen to test. I then made methods to handle
interactions between objects, these were tested during the testing of other objects. Finally, I developed a method to determine the
number of squares to any point on the grid from an arbitrary point. I tested this by printing the grid with numbers on each accessible
point to std::cout and making sure it worked correctly.

Actor:
Actor was assumed to function properly if all derived classes functioned properly.

TerrainObject:
TerrainObject was assumed to function properly if all derived classes functioned properly.

Interactable:
Interactable was assumed to function properly if all derived classes functioned properly.

Dirt:
Testing the Dirt class  involved first creating a single Dirt object using methods from StudentWorld. I assumed that a single dirt object
functioned correctly when it appeared on the field and was destroyed when the StudentWorld::removeDirt() method caused it to be removed
from the field.

Boulder:
To test Boulder, I first created a single Boulder and had it appear on the field. Then I created methods that would prevent othe objects
from travelling through boulders and tested collisions with the FrackMan. Then I developed a method to check if the space below the boulder
was free for it to fall and set the game text to "true" when it returned true. After implementing a method to causea Boulder to fall, I
checked that the Object was correctly destructed after falling. I then implemented a counter variable to transition between stable and
falling using a waiting state, it was fairly trivial and did not require extensive testing Finally, after implementing protesters and
FrackMan, I tested that a falling boulder caused 100 points of annoyance to those objects.

Water:
To test Water, I first had the object appear on the field when constructed, but do nothing else. Then, I used code similar to the 
lifetime determining code from the Gold class and ensured Water objects were destructed properly after a certain number of ticks.
Finally I implmented a method to increase the player's squirt count and destruct the object by interacting with the player and tested
it by placing an object on the field and running into it with the FrackMan.

Sonar:
Sonar was implemented and tested in the same manner as Water with only slight modifications to restrict the starting position and
update the sonar charge count instead of the squirt count.

Squirt:
I first has a Squirt appear as a stationary object on the field. Then I had pressing the spacebar trigger the creation of a Squirt at the
same position as the FrackMan. Afterwards, I had the Squirt move away from the FrackMan for up to 4 squares. After this, I had creation
of the Squirt occur in front of the FrackMan. I then implemented protesters and had them get annoyed by a Squirt. Finally I tried firing
squirts into Dirt, Boulders and out of bounds and made sure they did not appear.

Oil:
To test Oil. I had it appear invisible on the field upon creation, and appear when space was pressed. I then changed the condition
for appearance to be being within 4.0 of the FrackMan and for it to be destructed within 3.0 units. After doing so, I had oil's destruction
cause StudentWorld's count of remaining oil to decrement, and make sure it could not go below 0. Then I caused Oil to increase score when
the player interacted with it.

Gold:
To test Gold, I first tested cases in which it interacted with the FrackMan in a manner similar to Oil. Then, I had interaction with a
Protester kill the protester and increase score. Finally I implemented a counter variable to determine the Gold's remaining time
on the field and made sure it was destructed correctly when the variable reached 0 (the variable was printed to the top of the 
screen by StudentWorld).

Protester:
I first implemented protesters similarly to FrackMan and had them respond to keyboard input. Then, I implemented random movement
on a blank field and made sure it moved continuously. Then I disabled random movement and created a method to cause movement if it
overlapped either horizontally or vertically with the FrackMan. I again disabled all movement and implemented a method to annoy the
FrackMan if the Protester was facing it and within 4. Then, I allowed Squirts and Boulders to cause Protesters annoyance and printed
their health to the screen to ensure it decreased. Then I caused full annoyance to kill the Protester. After implementing a method
in StudentWorld to determine the path to an arbitrary point I made Protesters follow a path to the exit from random positions on the
grid to test that.

HardcoreProtester:
To test HardcoreProtester I first made sure Protester worked fully aside from path-finding to the exit, and made HardcoreProtesters
function in the same way. Then, I created a new method for bribery that caused them to be stunned, and tested to make sure they were
stunned rather than being forced to leave the field. After implementing the field exit method for Protesters, I modified it slightly
to allow HardcoreProtesters to chase the player and tested it by having them follow me around the map when playing regardless of 
distance. After verifying it worked, I implemented a maximum distance check for it, then inserted it into the normal movement
decision tree.

FrackMan:
To test the FrackMan, I initially made pressing enter cause the level to end, rather than having it end imediately. Then I implemented
movement using the arrow keys and made sure that movement outside the bounds of the field was impossible. I then tested the FrackMan's
ability to move through dirt and do not move through Boulders. After implementing all objects that the FrackMan could drop, I tested
the keybindings for each by giving 100 of each to the FrackMan and dropping them all. I then implemented the a method to show all objects
within a certain radius to act as a sonar kit. Then I developed a method to allow the frackman to be annoyed when the space key was pressed,
after verifying it worked, I changed the trigger to be interactions with falling Boulders or Protesters;